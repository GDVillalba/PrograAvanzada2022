#include<LiquidCrystal.h>

// Habilitacion de debug para la impresion por el puerto serial ...
//----------------------------------------------
#define SERIAL_DEBUG_ENABLED 1

#if SERIAL_DEBUG_ENABLED
  #define DebugPrint(str)\
    {\
        Serial.println(str);\
    }
#else
  #define DebugPrint(str)
#endif

#define DebugPrintEstado(estado,evento)\
    {\
        String est = estado;\
        String evt = evento;\
        String str;\
        str = "-----------------------------------------------------";\
        DebugPrint(str);\
        str = "De Estado: [ " + est + " ] y Evento: [ " + evt + " ] pasa a ->";\
        DebugPrint(str);\
        str = "-----------------------------------------------------";\
        DebugPrint(str);\
    }
#define DebugPrintEstadoActual(estado)\
    {\
        String est = estado;\
        String str;\
        str = "Estado actual: [ " + estado + " ].";\
        DebugPrint(str);\
    }
//----------------------------------------------
// Para pasar el valor del sensor TMP36 a grados centigrados
#define pasarAGradosCelsius(lectura) (((((lectura) * 5.0) / 1024)*100) - 50)

//----------------------------------------------
// Definicion de pines
#define PIN_SENSOR_TEMPERATURA                  0
#define PIN_PULSADOR_MAS                        2
#define PIN_PULSADOR_MENOS                      3
#define PIN_PULSADOR_VELOCIDAD                  4
#define PIN_PULSADOR_ON_OFF                     5
#define PIN_TRANSISTOR_MOTOR                    6
#define PIN_TRANSISTOR_ON_OFF                   7
#define PIN_LCD_RS                              8
#define PIN_LCD_E                               9
#define PIN_LCD_DB4                            10
#define PIN_LCD_DB5                            11
#define PIN_LCD_DB6                            12
#define PIN_LCD_DB7                            13
//----------------------------------------------

//----------------------------------------------
// Constantes 
#define MAX_TERMOSTATO                         35
#define INIT_TERMOSTATO                        24
#define MIN_TERMOSTATO                         18
#define MAX_VELOCIDAD                           3
#define MIN_VELOCIDAD                           1
#define DELTA_VELOCIDAD     (255 / MAX_VELOCIDAD)

#define CONT_TIMER_REINICIO                     0
#define SEGUNDOS_TIMER                          1
#define CONT_TIMER_MAX      (30 * SEGUNDOS_TIMER)

#define CANT_SENSORES                           5
#define SENSOR_TEMPERATURA                      0
#define SENSOR_PULSADOR_ON_OFF                  1
#define SENSOR_PULSADOR_VELOCIDAD               2
#define SENSOR_PULSADOR_TERMOSTATO_MENOS        3
#define SENSOR_PULSADOR_TERMOSTATO_MAS          4

#define VALOR_0                                 0
#define COLUMNAS_LCD                           16
#define FILAS_LCD                               2
#define DELTA_TIMEOUT                          50

//----------------------------------------------
// Definicion de estructuras
//----------------------------------------------
struct st_valores_globales
{
    int Temperatura;
    int Termostato;
    int Velocidad;
};

struct stSensor
{
    int  pin;
    int valor;
};

//----------------------------------------------
// Variables Globales
//----------------------------------------------
st_valores_globales value;
stSensor sensores[CANT_SENSORES];

//declaracion e inicializacion de la variable LiquidCrystal para controlar el display.
LiquidCrystal lcd(PIN_LCD_RS, PIN_LCD_E, PIN_LCD_DB4, PIN_LCD_DB5, PIN_LCD_DB6, PIN_LCD_DB7);

//variables para buscar un nuevo evento cada timeout
bool timeout;
long lct;

//----------------------------------------------

enum states          { ST_INIT   , ST_REPOSO   ,  ST_ACTIVO_ON   , ST_ACTIVO_OFF   , ST_ERROR   } current_state;
String states_s [] = {"ST_INIT"  ,"ST_REPOSO"  , "ST_ACTIVO_ON"  ,"ST_ACTIVO_OFF"  ,"ST_ERROR"  };

enum events          { EV_CONT   , EV_UPDATE_TEMP   , EV_ON_OFF   , EV_CAMBIO_VELOCIDAD   , EV_TERM_DOWN   , EV_TERM_UP   , EV_UNKNOW  } new_event;
String events_s [] = {"EV_CONT"  ,"EV_UPDATE_TEMP"  ,"EV_ON_OFF"  ,"EV_CAMBIO_VELOCIDAD"  ,"EV_TERM_DOWN"  ,"EV_TERM_UP"  ,"EV_UNKNOW" };

#define MAX_STATES 5
#define MAX_EVENTS 6

typedef void (*transition)();

transition state_table[MAX_STATES][MAX_EVENTS] =
{
      {init_    , error           , error         , error               , error         , error       } , // state ST_INIT
      {none     , update_temp     , activar       , none                , none          , none        } , // state ST_REPOSO
      {none     , check_v_on      , reposar       , update_vel          , t_abajo       , t_arriba    } , // state ST_ACTIVO_ON
      {none     , check_v_off     , reposar       , update_vel          , t_abajo       , t_arriba    } , // state ST_ACTIVO_OFF
      {error    , error           , error         , error               , error         , error       }   // state ST_ERROR
      
     //EV_CONT  , EV_UPDATE_TEMP  , EV_ON_OFF     , EV_CAMBIO_VELOCIDAD , EV_TERM_DOWN  , EV_TERM_UP
};

//----------------------------------------------
//###############################################
//### Funciones del temporizador por hardware ###
//###############################################
//----------------------------------------------

//Inicializacion del temporizador por HW
void inicializar_timer_por_HW()
{  
    // Limpiar el registro que guarda la cuenta del Timer-1
    TCNT1 = 0;                               
    // El pin OC1A cambia de estado tras la comparaci贸n.
    TCCR1A = 0b00000000;
    // Usa el registro OCR1A para comparar y factor escala 8.
    TCCR1B = 0b00001101;
    // Para que la interrupci贸n ocurra al segundo.
    OCR1A = 15624;
    // Se utilizara la interrupci贸n timer1 por comparaci贸n.
    TIMSK1 = bit(OCIE1A);
    // Habilita las interrupciones globales.
    sei();
}

//Funcion que lanza el temporizador por HW, se ejecuta cada 1 segundo aproximadamente.
ISR(TIMER1_COMPA_vect){
    leerTemperatura();
}

//----------------------------------------------
//##########################################################
//### Funciones para inicializar componentes y variables ###
//##########################################################
//----------------------------------------------
void do_init()
{
    //inicia Monitor en serie
    Serial.begin(9600);
    
    //inicia pines de pulsadores
    pinMode(PIN_PULSADOR_ON_OFF, INPUT);
    pinMode(PIN_PULSADOR_VELOCIDAD, INPUT);
    pinMode(PIN_PULSADOR_MENOS, INPUT);
    pinMode(PIN_PULSADOR_MAS, INPUT);
    
    //inicia pines de transistores
    pinMode(PIN_TRANSISTOR_MOTOR, OUTPUT);
    pinMode(PIN_TRANSISTOR_ON_OFF, OUTPUT);
    
    //inicia valores iniciales
    leerTemperatura();
    value.Velocidad = MIN_VELOCIDAD;
    value.Termostato = INIT_TERMOSTATO;
    
    //inicia estructuras de sensores
    sensores[SENSOR_TEMPERATURA].pin    = PIN_SENSOR_TEMPERATURA;
    sensores[SENSOR_TEMPERATURA].valor = value.Temperatura;
    
    sensores[SENSOR_PULSADOR_ON_OFF].pin    = PIN_PULSADOR_ON_OFF;
    sensores[SENSOR_PULSADOR_ON_OFF].valor = VALOR_0;
    
    sensores[SENSOR_PULSADOR_VELOCIDAD].pin    = PIN_PULSADOR_VELOCIDAD;
    sensores[SENSOR_PULSADOR_VELOCIDAD].valor = VALOR_0;
    
    sensores[SENSOR_PULSADOR_TERMOSTATO_MENOS].pin    = PIN_PULSADOR_MENOS;
    sensores[SENSOR_PULSADOR_TERMOSTATO_MENOS].valor = VALOR_0;
    
    sensores[SENSOR_PULSADOR_TERMOSTATO_MAS].pin    = PIN_PULSADOR_MAS;
    sensores[SENSOR_PULSADOR_TERMOSTATO_MAS].valor = VALOR_0;
    
    //escribe estado inicial del motor
    analogWrite(PIN_TRANSISTOR_MOTOR, value.Velocidad * DELTA_VELOCIDAD);
    
    //inicio el display
    lcd.begin(COLUMNAS_LCD, FILAS_LCD);
    
    // Inicializo el estado inicial de la maquina de estados
    current_state = ST_INIT;
    
    //inician variables auxiliares
    timeout = false;
    lct     = millis();
    dibujarDisplayOff();
    inicializar_timer_por_HW();
}

//----------------------------------------------------------
//#########################################
//### Funciones para dibujar el Display ###
//#########################################
//----------------------------------------------------------
void dibujarDisplayOn()
{
    lcd.setCursor(0,0);
    lcd.print("Vel:");
    lcd.print(value.Velocidad);
    lcd.setCursor(8,0);
    lcd.print(" Ter: ");
    lcd.print(value.Termostato);
    lcd.setCursor(0,1);
    //imprime espacios de mas para borrar la temperatura anterior
    lcd.print("Temperatura:    ");
    lcd.setCursor(13,1); 
    lcd.print(value.Temperatura); 
}

void dibujarDisplayOff()
{
    lcd.setCursor(0,0);
    lcd.print("                ");
    lcd.setCursor(0,1);
    //imprime espacios de mas para borrar la temperatura anterior
    lcd.print("Temperatura:    ");
    lcd.setCursor(13,1);
    lcd.print(value.Temperatura); 
}

//----------------------------------------------------------
//##################################################
//### Funciones que modifican variables globales ###
//##################################################
//----------------------------------------------------------
void leerTemperatura()
{
    value.Temperatura = pasarAGradosCelsius(analogRead(PIN_SENSOR_TEMPERATURA));
}
//----------------------------------------------------------
void cambioVelocidad()
{
    //Incrementa Velocidad en 1
    value.Velocidad = value.Velocidad + 1;
    //Si supera maxima velocidad vuelve al minimo
    if(value.Velocidad > MAX_VELOCIDAD)
    {
        value.Velocidad = MIN_VELOCIDAD;
    }
    //establece la velocidad en el motor
    analogWrite(PIN_TRANSISTOR_MOTOR, value.Velocidad * DELTA_VELOCIDAD);    
}
//----------------------------------------------------------
void termostatoMenos()
{
    //Decremento el termostato solo si no es el minimo
    if(value.Termostato > MIN_TERMOSTATO)
        value.Termostato--;
}

//----------------------------------------------------------
void termostatoMas()
{
    //Incremento el termostato solo si no es el maximo
    if(value.Termostato < MAX_TERMOSTATO)
        value.Termostato++;
}
//----------------------------------------------------------
//########################################################
//### Funciones verificar eventos (para get_new_event) ###
//########################################################
//----------------------------------------------------------
bool verificarTemperatura()
{
    //Verifica si la temperatura cambio, para disparar el EV_UPDATE_TEMP
    if( value.Temperatura != sensores[SENSOR_TEMPERATURA].valor)
    {
        sensores[SENSOR_TEMPERATURA].valor = value.Temperatura;
        new_event = EV_UPDATE_TEMP;
        return true;
    }
    
    return false;
}
//----------------------------------------------------------
bool verificarOnOff()
{
    //Si el pulsador se presiona dispara el evento
    if(pulsadorPresionado(SENSOR_PULSADOR_ON_OFF))
    {
        new_event = EV_ON_OFF;
        return true;
    }
    return false;
}
//----------------------------------------------------------
bool verificarVel()
{
    //Si el pulsador se presiona dispara el evento
    if(pulsadorPresionado(SENSOR_PULSADOR_VELOCIDAD))
    {
        new_event = EV_CAMBIO_VELOCIDAD;
        return true;
    }
    return false;
}
//----------------------------------------------------------
bool verificarTerMenos()
{
    //Si el pulsador se presiona dispara el evento
    if(pulsadorPresionado(SENSOR_PULSADOR_TERMOSTATO_MENOS))
    {
        new_event = EV_TERM_DOWN;
        return true;
    }
    return false;
}
//----------------------------------------------------------
bool verificarTerMas()
{
    //Si el pulsador se presiona dispara el evento
    if(pulsadorPresionado(SENSOR_PULSADOR_TERMOSTATO_MAS))
    {
        new_event = EV_TERM_UP;
        return true;
    }
    return false;
}
//----------------------------------------------------------
bool pulsadorPresionado(int pulsador)
{
    int lectura = digitalRead(sensores[pulsador].pin);
    //Verifica si hay cambio de estado en el pin
    if(sensores[pulsador].valor != lectura)
    {
        //Si cambio el estado se actualiza
        sensores[pulsador].valor = lectura;
        //verifico que sea un cambio de LOW a HIGH
        if( lectura == HIGH )
        {
            return true;
        }
    }
    return false;
}
//----------------------------------------------------------
//############################
//### Funciones transition ###
//############################
//----------------------------------------------------------
void init_()
{
    DebugPrintEstado(states_s[current_state], events_s[new_event]);
    
    current_state = ST_REPOSO;
    
    DebugPrintEstadoActual(states_s[current_state]);
}
//----------------------------------------------------------
void error()
{
    Serial.println("#######   ERROR   ###########");
}
//----------------------------------------------------------
void none()
{
    //No hace nada.
}
//----------------------------------------------------------
void update_temp()
{
    //Actualizar display
    dibujarDisplayOff();
}
//----------------------------------------------------------
void activar()
{
    //si la Temperatura del termostato se alcanzo, apago el motor
    if(value.Temperatura > value.Termostato )
    {
        //Prendo motor y cambio a estado ST_ACTIVO_ON
        digitalWrite( PIN_TRANSISTOR_ON_OFF , HIGH);
        current_state = ST_ACTIVO_ON;
    }else{
        //Apago motor y cambio a estado ST_ACTIVO_OFF
        digitalWrite( PIN_TRANSISTOR_ON_OFF , LOW);
        current_state = ST_ACTIVO_OFF;
    }
    //Actualizar display
    dibujarDisplayOn();
}
//----------------------------------------------------------
void check_v_on()
{
    //si la Temperatura del termostato se alcanzo, apago el motor
    if(value.Temperatura <= value.Termostato )
    {
        //Apago motor y cambio a estado ST_ACTIVO_OFF
        digitalWrite( PIN_TRANSISTOR_ON_OFF , LOW);
        current_state = ST_ACTIVO_OFF;
    }
    //Actualizar display
    dibujarDisplayOn();
}
//----------------------------------------------------------
void check_v_off()
{
    //si la Temperatura del termostato se alcanzo, apago el motor
    if(value.Temperatura > value.Termostato )
    {
        //Prendo motor y cambio a estado ST_ACTIVO_ON
        digitalWrite( PIN_TRANSISTOR_ON_OFF , HIGH);
        current_state = ST_ACTIVO_ON;
    }
    //Actualizar display
    dibujarDisplayOn();
}
//----------------------------------------------------------
void reposar()
{
    //Apago motor y cambio a estado ST_REPOSO
    digitalWrite( PIN_TRANSISTOR_ON_OFF , LOW);
    current_state = ST_REPOSO;
    //Actualizar display
    dibujarDisplayOff();
}
//----------------------------------------------------------
void update_vel()
{
    cambioVelocidad();
    dibujarDisplayOn();
}
//----------------------------------------------------------
void t_abajo()
{
    termostatoMenos();
    activar();
    //Actualizar display
    dibujarDisplayOn();
}  
//----------------------------------------------------------
void t_arriba()
{
    termostatoMas();
    activar();
    //Actualizar display
    dibujarDisplayOn();
}
//----------------------------------------------------------
//################################################
//### Funciones generales de estados y eventos ###
//################################################
//----------------------------------------------
void get_new_event( )
{
    long ct = millis();
    int  diferencia = (ct - lct);
    timeout = (diferencia > DELTA_TIMEOUT)? (true):(false);
    
    if( timeout )
    {
        // Doy acuse de la recepcion del timeout
        timeout = false;
        lct     = ct;
        
        if( (verificarTemperatura() == true) || (verificarOnOff() == true) || (verificarVel() == true) || (verificarTerMenos() == true) || (verificarTerMas() == true) )
        {
            return;
        }
    }
  
    // Genero evento dummy ....
    new_event = EV_CONT;
}
//----------------------------------------------
void maquina_de_estados()
{
    get_new_event();
    
    if( (new_event >= 0) && (new_event < MAX_EVENTS) && (current_state >= 0) && (current_state < MAX_STATES) )
    {
        if( new_event != EV_CONT )
        {
            DebugPrintEstado(states_s[current_state], events_s[new_event]);
        }
        
        state_table[current_state][new_event]();
        
        if( new_event != EV_CONT )
        {
            DebugPrintEstadoActual(states_s[current_state]);
        }
    }
    else
    {
        DebugPrintEstado(states_s[ST_ERROR], events_s[EV_UNKNOW]);
    }
  
    // Consumo el evento...
    new_event   = EV_CONT;
}
//----------------------------------------------
//############################
//### Funciones de Arduino ###
//############################
//----------------------------------------------
void setup() {
    do_init(); 
}
//----------------------------------------------
void loop() {
    maquina_de_estados();  
}